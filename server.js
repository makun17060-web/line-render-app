// server.js â€” ãƒ•ãƒ«æ©Ÿèƒ½ç‰ˆ + Flexé…ä¿¡ + ã€Œãã®ä»–ï¼ä¾¡æ ¼å…¥åŠ›ãªã—ã€ + ä¹…åŠ©å°‚ç”¨ãƒ†ã‚­ã‚¹ãƒˆè³¼å…¥ãƒ•ãƒ­ãƒ¼ // + äºˆç´„è€…é€£çµ¡API/ã‚³ãƒãƒ³ãƒ‰ + åº—é ­å—å–/äºˆç´„ã§åå‰å…¥åŠ›ãƒ•ãƒ­ãƒ¼ + å®…é…Ã—éŠ€è¡ŒæŒ¯è¾¼ã§æŒ¯è¾¼å…ˆï¼†è¿½è¨˜ã‚³ãƒ¡ãƒ³ãƒˆè‡ªå‹•é€ä¿¡ // .env å¿…é ˆ: LINE_CHANNEL_ACCESS_TOKEN, LINE_CHANNEL_SECRET, LIFF_ID, (ADMIN_API_TOKEN or ADMIN_CODE) // ä»»æ„: PORT, ADMIN_USER_ID, MULTICAST_USER_IDS, BANK_INFO, BANK_NOTE "use strict"; require("dotenv").config(); const fs = require("fs"); const path = require("path"); const express = require("express"); const line = require("@line/bot-sdk"); const axios = require("axios"); const app = express(); // ====== ENV ====== const PORT = process.env.PORT || 3000; const LIFF_ID = (process.env.LIFF_ID || "").trim(); const ADMIN_USER_ID = (process.env.ADMIN_USER_ID || "").trim(); const MULTICAST_USER_IDS = (process.env.MULTICAST_USER_IDS || "") .split(",").map(s => s.trim()).filter(Boolean); const ADMIN_API_TOKEN_ENV = (process.env.ADMIN_API_TOKEN || "").trim(); const ADMIN_CODE_ENV = (process.env.ADMIN_CODE || "").trim(); const BANK_INFO = (process.env.BANK_INFO || "").trim(); // æŒ¯è¾¼å…ˆ const BANK_NOTE = (process.env.BANK_NOTE || "").trim(); // è¿½è¨˜ã‚³ãƒ¡ãƒ³ãƒˆ const config = { channelAccessToken: (process.env.LINE_CHANNEL_ACCESS_TOKEN || "").trim(), channelSecret: (process.env.LINE_CHANNEL_SECRET || "").trim(), }; if (!config.channelAccessToken || !config.channelSecret || !LIFF_ID || (!ADMIN_API_TOKEN_ENV && !ADMIN_CODE_ENV)) { console.error("ERROR: .env ã®å¿…é ˆå€¤ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚LINE_* / LIFF_ID / (ADMIN_API_TOKEN or ADMIN_CODE)"); process.exit(1); } // ====== Middlewares & Static ====== app.use("/api", express.json(), express.urlencoded({ extended: true })); app.use("/public", express.static(path.join(__dirname, "public"))); app.get("/", (_req, res) => res.status(200).send("OK")); // ====== Data paths ====== const DATA_DIR = path.join(__dirname, "data"); const PRODUCTS_PATH = path.join(DATA_DIR, "products.json"); const ORDERS_LOG = path.join(DATA_DIR, "orders.log"); const RESERVATIONS_LOG = path.join(DATA_DIR, "reservations.log"); const ADDRESSES_PATH = path.join(DATA_DIR, "addresses.json"); // åå‰/ä½æ‰€/é›»è©±ã‚’ä¿å­˜ï¼ˆåå‰ã ã‘ã®ä¿å­˜ã‚‚OKï¼‰ const SURVEYS_LOG = path.join(DATA_DIR, "surveys.log"); const MESSAGES_LOG = path.join(DATA_DIR, "messages.log"); const SESSIONS_PATH = path.join(DATA_DIR, "sessions.json"); const STOCK_LOG = path.join(DATA_DIR, "stock.log"); const NOTIFY_STATE_PATH= path.join(DATA_DIR, "notify_state.json"); if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true }); if (!fs.existsSync(ADDRESSES_PATH)) fs.writeFileSync(ADDRESSES_PATH, JSON.stringify({}, null, 2), "utf8"); if (!fs.existsSync(SESSIONS_PATH)) fs.writeFileSync(SESSIONS_PATH, JSON.stringify({}, null, 2), "utf8"); if (!fs.existsSync(NOTIFY_STATE_PATH)) fs.writeFileSync(NOTIFY_STATE_PATH, JSON.stringify({}, null, 2), "utf8"); if (!fs.existsSync(PRODUCTS_PATH)) { const sample = [ { id: "kusuke-250", name: "ä¹…åŠ©ï¼ˆãˆã³ã›ã‚“ï¼‰", price: 250, stock: 20, desc: "ãŠå¾—ãªå‰²ã‚Œã›ã‚“ã€‚" }, { id: "nori-akasha-340", name: "ã®ã‚Šã‚ã‹ã—ã‚ƒ", price: 340, stock: 20, desc: "æµ·è‹”ã®é¢¨å‘³è±Šã‹ãªãˆã³ã›ã‚“ã¹ã„" }, { id: "uzu-akasha-340", name: "ã†ãšã‚ã‹ã—ã‚ƒ", price: 340, stock: 10, desc: "æ¸¦ã‚’å·»ã„ãŸãˆã³ã›ã‚“ã¹ã„" }, { id: "matsu-akasha-340",name: "æ¾ã‚ã‹ã—ã‚ƒ", price: 340, stock: 30, desc: "æµ·è€ã‚’ãŸã£ã·ã‚Šä½¿ç”¨ã—ãŸé«˜ç´šãˆã³ã›ã‚“ã¹ã„" }, ]; fs.writeFileSync(PRODUCTS_PATH, JSON.stringify(sample, null, 2), "utf8"); console.log(â„¹ï¸ åˆæœŸ products.json ã‚’ä½œæˆ: ${PRODUCTS_PATH}); } // ====== Configs ====== const LOW_STOCK_THRESHOLD = 5; const PRODUCT_ALIASES = { "ä¹…åŠ©": "kusuke-250", "ãã™ã‘": "kusuke-250", "kusuke": "kusuke-250", "kusuke-250": "kusuke-250", }; // ä¸€è¦§ã‹ã‚‰éš ã™ï¼ˆä¹…åŠ©ã¯ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›å°ç·šã§è³¼å…¥ï¼‰ const HIDE_PRODUCT_IDS = new Set(["kusuke-250"]); // ====== Utils ====== const client = new line.Client(config); const safeReadJSON = (p, fb) => { try { return JSON.parse(fs.readFileSync(p, "utf8")); } catch { return fb; } }; const readProducts = () => safeReadJSON(PRODUCTS_PATH, []); const writeProducts = (data) => fs.writeFileSync(PRODUCTS_PATH, JSON.stringify(data, null, 2), "utf8"); const readAddresses = () => safeReadJSON(ADDRESSES_PATH, {}); const writeAddresses = (data) => fs.writeFileSync(ADDRESSES_PATH, JSON.stringify(data, null, 2), "utf8"); const readSessions = () => safeReadJSON(SESSIONS_PATH, {}); const writeSessions = (s) => fs.writeFileSync(SESSIONS_PATH, JSON.stringify(s, null, 2), "utf8"); const readNotifyState = () => safeReadJSON(NOTIFY_STATE_PATH, {}); const writeNotifyState = (s) => fs.writeFileSync(NOTIFY_STATE_PATH, JSON.stringify(s, null, 2), "utf8"); const yen = (n) => ${Number(n || 0).toLocaleString("ja-JP")}å††; const qstr = (obj) => Object.entries(obj).map(([k, v]) => ${encodeURIComponent(k)}=${encodeURIComponent(v)}).join("&"); const parse = (data) => { const s = data && data.includes("=") ? data : ""; const o = {}; s.split("&").forEach(kv => { const [k, v] = kv.split("="); if (k) o[decodeURIComponent(k)] = decodeURIComponent(v || ""); }); return o; }; const uniq = (arr) => Array.from(new Set((arr||[]).filter(Boolean))); function readLogLines(filePath, limit = 100) { if (!fs.existsSync(filePath)) return []; const lines = fs.readFileSync(filePath, "utf8").split(/\r?\n/).filter(Boolean); const tail = lines.slice(-Math.min(Number(limit)||100, lines.length)); return tail.map(l => { try { return JSON.parse(l); } catch { return null; } }).filter(Boolean); } // stock helpers function findProductById(pid) { const products = readProducts(); const idx = products.findIndex(p => p.id === pid); return { products, idx, product: idx >= 0 ? products[idx] : null }; } function resolveProductId(token) { return PRODUCT_ALIASES[token] || token; } function writeStockLog(entry) { try { fs.appendFileSync(STOCK_LOG, JSON.stringify({ ts:new Date().toISOString(), ...entry }) + "\n", "utf8"); } catch {} } function setStock(productId, qty, actor = "system") { const q = Math.max(0, Number(qty)||0); const { products, idx, product } = findProductById(productId); if (idx < 0) throw new Error("product_not_found"); const before = Number(product.stock || 0); products[idx].stock = q; writeProducts(products); writeStockLog({ action:"set", productId, before, after:q, delta:(q-before), actor }); return { before, after:q }; } function addStock(productId, delta, actor = "system") { const d = Number(delta)||0; const { products, idx, product } = findProductById(productId); if (idx < 0) throw new Error("product_not_found"); const before = Number(product.stock || 0); const after = Math.max(0, before + d); products[idx].stock = after; writeProducts(products); writeStockLog({ action:"add", productId, before, after, delta:d, actor }); return { before, after }; } async function maybeLowStockAlert(productId, productName, stockNow) { if (stockNow < LOW_STOCK_THRESHOLD) { const msg = âš ï¸ åœ¨åº«åƒ…å°‘\nå•†å“ï¼š${productName}ï¼ˆ${productId}ï¼‰\næ®‹ã‚Šï¼š${stockNow}å€‹ï¼ˆã—ãã„å€¤ ${LOW_STOCK_THRESHOLD}ï¼‰; try { if (ADMIN_USER_ID) await client.pushMessage(ADMIN_USER_ID, { type:"text", text: msg }); } catch {} } } // auth helpers function bearerToken(req) { const h = req.headers?.authorization || req.headers?.Authorization || ""; const m = /^Bearer\s+(.+)$/i.exec(h); return m ? m[1].trim() : null; } function requireAdmin(req, res) { const headerTok = bearerToken(req); const queryTok = (req.query?.token || req.query?.code || "").trim(); const tok = headerTok || queryTok; if (ADMIN_API_TOKEN_ENV && tok === ADMIN_API_TOKEN_ENV) return true; if (ADMIN_CODE_ENV && tok === ADMIN_CODE_ENV) return true; res.status(401).json({ ok:false, error:"unauthorized" }); return false; } // time range helpers (JST day) function jstRangeFromYmd(ymd) { const y = Number(ymd.slice(0,4)), m = Number(ymd.slice(4,6))-1, d = Number(ymd.slice(6,8)); const startJST = new Date(Date.UTC(y, m, d, -9, 0, 0)); const endJST = new Date(Date.UTC(y, m, d+1, -9, 0, 0)); return { from: startJST.toISOString(), to: endJST.toISOString() }; } function filterByIsoRange(items, getTs, fromIso, toIso) { if (!fromIso && !toIso) return items; const from = fromIso ? new Date(fromIso).getTime() : -Infinity; const to = toIso ? new Date(toIso).getTime() : Infinity; return items.filter(it => { const t = new Date(getTs(it)).getTime(); return t >= from && t < to; }); } // ====== é€æ–™/ä»£å¼•ã ====== const SHIPPING_BY_REGION = { "åŒ—æµ·é“": 1100, "æ±åŒ—": 900, "é–¢æ±": 800, "ä¸­éƒ¨": 800, "è¿‘ç•¿": 900, "ä¸­å›½": 1000, "å››å›½": 1000, "ä¹å·": 1100, "æ²–ç¸„": 1400 }; const COD_FEE = 330; // ====== Flex Builders ====== function ensureAltText(altText) { const s = String(altText || "").trim(); if (!s) throw new Error("altText is required"); if (s.length > 400) throw new Error("altText too long (<=400)"); return s; } function validateFlexContents(contents) { if (!contents || typeof contents !== "object") throw new Error("contents must be object"); const t = contents.type; if (t !== "bubble" && t !== "carousel") throw new Error('contents.type must be "bubble" or "carousel"'); return contents; } function productsFlex(allProducts) { const products = (allProducts || []).filter(p => !HIDE_PRODUCT_IDS.has(p.id)); const bubbles = products.map(p => ({ type: "bubble", body: { type: "box", layout: "vertical", spacing: "sm", contents: [ { type: "text", text: p.name, weight: "bold", size: "md", wrap: true }, { type: "text", text: ä¾¡æ ¼ï¼š${yen(p.price)}ã€€åœ¨åº«ï¼š${p.stock ?? 0}, size: "sm", wrap: true }, p.desc ? { type: "text", text: p.desc, size: "sm", wrap: true } : { type: "box", layout: "vertical", contents: [] } ] }, footer: { type: "box", layout: "horizontal", spacing: "md", contents: [ { type: "button", style: "primary", action: { type: "postback", label: "æ•°é‡ã‚’é¸ã¶", data: order_qty?${qstr({ id: p.id, qty: 1 })} } } ] } })); // ã€Œãã®ä»–ï¼ˆè‡ªç”±å…¥åŠ›ï¼‰ã€ï¼šä¾¡æ ¼å…¥åŠ›ãªã—ï¼ˆåå‰â†’å€‹æ•°â†’å—å–æ–¹æ³•ã¸ï¼‰ bubbles.push({ type: "bubble", body: { type: "box", layout: "vertical", spacing: "sm", contents: [ { type: "text", text: "ãã®ä»–ï¼ˆè‡ªç”±å…¥åŠ›ï¼‰", weight: "bold", size: "md" }, { type: "text", text: "å•†å“åã¨å€‹æ•°ã ã‘å…¥åŠ›ã—ã¾ã™ã€‚ä¾¡æ ¼å…¥åŠ›ã¯ä¸è¦ã§ã™ã€‚", size: "sm", wrap: true } ] }, footer: { type: "box", layout: "vertical", spacing: "md", contents: [ { type: "button", style: "primary", action: { type: "postback", label: "å•†å“åã‚’å…¥åŠ›ã™ã‚‹", data: "other_start" } }, { type: "button", style: "secondary", action: { type: "postback", label: "â† æˆ»ã‚‹", data: "order_back" } } ] } }); return { type: "flex", altText: "å•†å“ä¸€è¦§", contents: bubbles.length === 1 ? bubbles[0] : { type: "carousel", contents: bubbles } }; } function qtyFlex(id, qty = 1) { const q = Math.max(1, Math.min(99, Number(qty) || 1)); return { type: "flex", altText: "æ•°é‡ã‚’é¸æŠã—ã¦ãã ã•ã„", contents: { type: "bubble", body: { type: "box", layout: "vertical", spacing: "md", contents: [ { type: "text", text: "æ•°é‡é¸æŠ", weight: "bold", size: "lg" }, { type: "text", text: ç¾åœ¨ã®æ•°é‡ï¼š${q} å€‹, size: "md" } ] }, footer: { type: "box", layout: "vertical", spacing: "md", contents: [ { type: "box", layout: "horizontal", spacing: "md", contents: [ { type: "button", style: "secondary", action: { type: "postback", label: "-1", data: order_qty?${qstr({ id, qty: Math.max(1, q - 1) })} } }, { type: "button", style: "secondary", action: { type: "postback", label: "+1", data: order_qty?${qstr({ id, qty: Math.min(99, q + 1) })} } }, ] }, { type: "box", layout: "horizontal", spacing: "md", contents: [1,2,3,5].map(n => ({ type: "button", style: n===q ? "primary" : "secondary", action: { type: "postback", label: ${n}å€‹, data: order_qty?${qstr({ id, qty: n })} } })) }, { type: "button", style: "primary", action: { type: "postback", label: "å—å–æ–¹æ³•ã¸", data: order_method?${qstr({ id, qty: q })} } }, { type: "button", style: "secondary", action: { type: "postback", label: "â† å•†å“ä¸€è¦§", data: "order_back" } } ] } } }; } function methodFlex(id, qty) { return { type: "flex", altText: "å—å–æ–¹æ³•ã‚’é¸æŠã—ã¦ãã ã•ã„", contents: { type: "bubble", body: { type: "box", layout: "vertical", spacing: "md", contents: [ { type: "text", text: "å—å–æ–¹æ³•", weight: "bold", size: "lg" }, { type: "text", text: "å®…é… ã¾ãŸã¯ åº—é ­å—å– ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚", wrap: true } ] }, footer: { type: "box", layout: "horizontal", spacing: "md", contents: [ { type: "button", style: "primary", action: { type: "postback", label: "å®…é…ï¼ˆé€æ–™ã‚ã‚Šï¼‰", data: order_region?${qstr({ id, qty, method: "delivery" })} } }, { type: "button", style: "secondary", action: { type: "postback", label: "åº—é ­å—å–ï¼ˆé€æ–™0å††ï¼‰", data: order_payment?${qstr({ id, qty, method: "pickup", region: "-" })} } } ] } } }; } function regionFlex(id, qty) { const regions = Object.keys(SHIPPING_BY_REGION); const rows = []; for (let i = 0; i < regions.length; i += 2) { rows.push({ type: "box", layout: "horizontal", spacing: "md", contents: regions.slice(i, i + 2).map(r => ({ type: "button", style: "secondary", action: { type: "postback", label: ${r}ï¼ˆ${yen(SHIPPING_BY_REGION[r])}ï¼‰, data: order_payment?${qstr({ id, qty, method: "delivery", region: r })} } })) }); } return { type: "flex", altText: "åœ°åŸŸé¸æŠ", contents: { type: "bubble", body: { type: "box", layout: "vertical", spacing: "md", contents: [ { type: "text", text: "åœ°åŸŸé¸æŠ", weight: "bold", size: "lg" }, { type: "text", text: "åœ°åŸŸã«ã‚ˆã‚Šé€æ–™ãŒç•°ãªã‚Šã¾ã™ã€‚", wrap: true } ] }, footer: { type: "box", layout: "vertical", spacing: "sm", contents: rows } } }; } // åº—é ­å—å–ï¼ç¾é‡‘ã®ã¿ã€‚åå‰æœªç™»éŒ²ã®å ´åˆã¯åå‰ã‚’å…ˆã«å–å¾—ã™ã‚‹å°ç·šã«åˆ‡æ›¿ãˆã‚‹ function paymentFlex(id, qty, method, region) { if (method === "pickup") { return { type: "flex", altText: "ãŠæ”¯æ‰•ã„ï¼ˆåº—é ­ï¼‰", contents: { type: "bubble", body: { type: "box", layout: "vertical", spacing: "md", contents: [ { type: "text", text: "ãŠæ”¯æ‰•ã„æ–¹æ³•", weight: "bold", size: "lg" }, { type: "text", text: "åº—é ­å—å–ã¯ç¾é‡‘ã®ã¿ã§ã™ã€‚ãŠå—ã‘å–ã‚Šã®éš›ã®ã€ŒãŠåå‰ã€ã‚’ãŠä¼ºã„ã—ã¾ã™ã€‚", wrap: true } ] }, footer: { type: "box", layout: "vertical", spacing: "md", contents: [ { type: "button", style: "primary", action: { type: "postback", label: "ç¾é‡‘ã§æ”¯æ‰•ã†ï¼ˆåº—é ­ï¼‰", data: order_confirm_view?${qstr({ id, qty, method: "pickup", region: "", payment: "cash" })} } }, { type: "button", style: "secondary", action: { type: "postback", label: "â† å—å–æ–¹æ³•ã¸æˆ»ã‚‹", data: order_method?${qstr({ id, qty })} } } ] } } }; } // å®…é…: ä»£å¼•ã or éŠ€è¡ŒæŒ¯è¾¼ const regionText = method === "delivery" ? ï¼ˆé…é€åœ°åŸŸï¼š${region}ï¼‰ : ""; return { type: "flex", altText: "ãŠæ”¯æ‰•ã„æ–¹æ³•ã‚’é¸æŠã—ã¦ãã ã•ã„", contents: { type: "bubble", body: { type: "box", layout: "vertical", spacing: "md", contents: [ { type: "text", text: "ãŠæ”¯æ‰•ã„æ–¹æ³•", weight: "bold", size: "lg" }, { type: "text", text: ä»£å¼•ãã¯ +${yen(COD_FEE)}${regionText}, wrap: true } ] }, footer: { type: "box", layout: "horizontal", spacing: "md", contents: [ { type: "button", style: "primary", action: { type: "postback", label: ä»£é‡‘å¼•æ›ï¼ˆ+${yen(COD_FEE)}ï¼‰, data: order_confirm_view?${qstr({ id, qty, method, region, payment: "cod" })} } }, { type: "button", style: "secondary", action: { type: "postback", label: "éŠ€è¡ŒæŒ¯è¾¼", data: order_confirm_view?${qstr({ id, qty, method, region, payment: "bank" })} } } ] } } }; } function confirmFlex(product, qty, method, region, payment, LIFF_ID) { // other:NAME(:PRICE)? if (typeof product?.id === "string" && product.id.startsWith("other:")) { const parts = product.id.split(":"); const encName = parts[1] || ""; const priceStr = parts[2] || "0"; product = { ...product, name: decodeURIComponent(encName || "ãã®ä»–"), price: Number(priceStr || 0) }; } const regionFee = method === "delivery" ? (SHIPPING_BY_REGION[region] || 0) : 0; const codFee = payment === "cod" ? COD_FEE : 0; const subtotal = Number(product.price) * Number(qty); const total = subtotal + regionFee + codFee; const payText = payment === "cod" ? ä»£é‡‘å¼•æ›ï¼ˆ+${yen(COD_FEE)}) : payment === "bank" ? "éŠ€è¡ŒæŒ¯è¾¼" : "ç¾é‡‘ï¼ˆåº—é ­ï¼‰"; const lines = [ å—å–æ–¹æ³•ï¼š${method === "pickup" ? "åº—é ­å—å–ï¼ˆé€æ–™0å††ï¼‰" : å®…é…ï¼ˆ${region}ï¼š${yen(regionFee)}ï¼‰}, æ”¯æ‰•ã„ï¼š${payText}, å•†å“ï¼š${product.name}, æ•°é‡ï¼š${qty}å€‹, å°è¨ˆï¼š${yen(subtotal)}, é€æ–™ï¼š${yen(regionFee)}, ä»£å¼•ãæ‰‹æ•°æ–™ï¼š${yen(codFee)}, åˆè¨ˆï¼š${yen(total)} ]; const bodyContents = [ { type: "text", text: "æœ€çµ‚ç¢ºèª", weight: "bold", size: "lg" }, ...lines.map(t => ({ type: "text", text: t, wrap: true })), ]; if (method === "delivery") { bodyContents.push({ type: "text", text: "ä½æ‰€ãŒæœªç™»éŒ²ã®æ–¹ã¯ã€Œä½æ‰€ã‚’å…¥åŠ›ï¼ˆLIFFï¼‰ã€ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚", size: "sm", wrap: true }); } const footerButtons = [ { type: "button", style: "secondary", action: { type: "postback", label: "â† å•†å“ä¸€è¦§ã¸", data: "order_back" } }, { type: "button", style: "primary", action: { type: "postback", label: "ã“ã®å†…å®¹ã§ç¢ºå®š", data: order_confirm?${qstr({ id: product.id, qty, method, region, payment })} } }, ]; if (method === "delivery") { footerButtons.unshift({ type: "button", style: "secondary", action: { type: "uri", label: "ä½æ‰€ã‚’å…¥åŠ›ï¼ˆLIFFï¼‰", uri: https://liff.line.me/${LIFF_ID}?${qstr({ from: "address", need: "shipping" })} } }); } return { type: "flex", altText: "æ³¨æ–‡å†…å®¹ã®æœ€çµ‚ç¢ºèª", contents: { type: "bubble", body: { type: "box", layout: "vertical", spacing: "md", contents: bodyContents }, footer: { type: "box", layout: "vertical", spacing: "md", contents: footerButtons } } }; } function reserveOffer(product, needQty, stock) { return [ { type: "text", text: [ "ç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ã€‚åœ¨åº«ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚", å•†å“ï¼š${product.name}, å¸Œæœ›æ•°é‡ï¼š${needQty}å€‹ / ç¾åœ¨åœ¨åº«ï¼š${stock}å€‹, "", "äºˆç´„ã—ã¾ã™ã‹ï¼Ÿ å…¥è·æ¬¡ç¬¬ã”æ¡ˆå†…ã—ã¾ã™ã€‚" ].join("\n") }, { type: "template", altText: "åœ¨åº«ä¸è¶³ï¼šäºˆç´„ã—ã¾ã™ã‹ï¼Ÿ", template: { type: "confirm", text: "äºˆç´„ã—ã¾ã™ã‹ï¼Ÿ", actions: [ { type: "postback", label: "äºˆç´„ã™ã‚‹", data: order_reserve?${qstr({ id: product.id, qty: needQty })} }, { type: "postback", label: "ã‚„ã‚ã‚‹", data: "order_cancel" } ] } } ]; } // ====== Survey (ãƒ€ãƒŸãƒ¼: ãƒœã‚¿ãƒ³ã ã‘) ====== const SURVEY_VERSION = 2; function surveyQ1() { return { type:"text", text:"ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆã¯æº–å‚™ä¸­ã§ã™ã€‚" }; } // ====== LIFF APIs ====== app.post("/api/liff/address", async (req, res) => { try { const { userId, name, phone, postal, prefecture, city, address1, address2 } = req.body || {}; if (!userId) return res.status(400).json({ ok: false, error: "userId required" }); const book = readAddresses(); book[userId] = { name: (name||"").trim(), phone: (phone||"").trim(), postal: (postal||"").trim(), prefecture: (prefecture||"").trim(), city: (city||"").trim(), address1: (address1||"").trim(), address2: (address2||"").trim(), ts: new Date().toISOString() }; writeAddresses(book); res.json({ ok: true }); } catch (e) { res.status(500).json({ ok: false, error: "server_error" }); } }); app.get("/api/liff/config", (_req, res) => res.json({ liffId: LIFF_ID })); // ====== Admin APIs ====== app.get("/api/admin/ping", (req, res) => { if (!requireAdmin(req, res)) return; res.json({ ok: true, ping: "pong" }); }); app.get("/api/admin/orders", (req, res) => { if (!requireAdmin(req, res)) return; const limit = Math.min(5000, Number(req.query.limit || 1000)); let items = readLogLines(ORDERS_LOG, limit); let range = {}; if (req.query.date) range = jstRangeFromYmd(String(req.query.date)); if (req.query.from || req.query.to) range = { from: req.query.from, to: req.query.to }; if (range.from || range.to) items = filterByIsoRange(items, x => x.ts, range.from, range.to); res.json({ ok: true, items }); }); app.get("/api/admin/reservations", (req, res) => { if (!requireAdmin(req, res)) return; const limit = Math.min(5000, Number(req.query.limit || 1000)); let items = readLogLines(RESERVATIONS_LOG, limit); let range = {}; if (req.query.date) range = jstRangeFromYmd(String(req.query.date)); if (req.query.from || req.query.to) range = { from: req.query.from, to: req.query.to }; if (range.from || range.to) items = filterByIsoRange(items, x => x.ts, range.from, range.to); res.json({ ok: true, items }); }); app.get("/api/admin/addresses", (req, res) => { if (!requireAdmin(req, res)) return; res.json({ ok: true, items: readAddresses() }); }); // åœ¨åº«ãƒ»ãƒ­ã‚° app.get("/api/admin/products", (req, res) => { if (!requireAdmin(req, res)) return; const items = readProducts().map(p => ({ id:p.id, name:p.name, price:p.price, stock:p.stock ?? 0, desc:p.desc || "" })); res.json({ ok:true, items }); }); app.get("/api/admin/stock/logs", (req, res) => { if (!requireAdmin(req, res)) return; const limit = Math.min(10000, Number(req.query.limit || 200)); const items = readLogLines(STOCK_LOG, limit); res.json({ ok:true, items }); }); app.post("/api/admin/stock/set", (req, res) => { if (!requireAdmin(req, res)) return; try{ const pid = resolveProductId((req.body?.productId || "").trim()); const qty = Number(req.body?.qty); const r = setStock(pid, qty, "api"); res.json({ ok:true, productId: pid, ...r }); }catch(e){ res.status(400).json({ ok:false, error:String(e.message||e) }); } }); app.post("/api/admin/stock/add", (req, res) => { if (!requireAdmin(req, res)) return; try{ const pid = resolveProductId((req.body?.productId || "").trim()); const delta = Number(req.body?.delta); const r = addStock(pid, delta, "api"); res.json({ ok:true, productId: pid, ...r }); }catch(e){ res.status(400).json({ ok:false, error:String(e.message||e) }); } }); // äºˆç´„è€…é€£çµ¡ï¼ˆã¾ã¨ã‚ã¦ï¼‰ app.post("/api/admin/reservations/notify", async (req, res) => { if (!requireAdmin(req, res)) return; try{ const pid = resolveProductId(String(req.body?.productId || "").trim()); const msg = String(req.body?.message || "").trim(); if (!pid) return res.status(400).json({ ok:false, error:"productId required" }); if (!msg) return res.status(400).json({ ok:false, error:"message required" }); const items = readLogLines(RESERVATIONS_LOG, 100000).filter(r => r && r.productId === pid && r.userId); const userIds = Array.from(new Set(items.map(r => r.userId))); if (userIds.length === 0) return res.json({ ok:true, sent:0, users:[] }); const chunk = 500; let sent = 0; for (let i=0;i<userIds.length;i+=chunk) { const ids = userIds.slice(i, i+chunk); try { await client.multicast(ids, [{ type:"text", text: msg }]); sent += ids.length; } catch(e){ console.error("notify multicast error:", e?.response?.data || e); } } res.json({ ok:true, productId: pid, requested:userIds.length, sent }); }catch(e){ res.status(500).json({ ok:false, error: String(e.message||e) }); } }); // é †æ¬¡é€šçŸ¥ï¼ˆé–‹å§‹/æ¬¡/åœæ­¢ï¼‰ function buildReservationQueue(productId) { const all = readLogLines(RESERVATIONS_LOG, 200000) .filter(r => r && r.productId === productId && r.userId && r.ts) .sort((a,b) => new Date(a.ts) - new Date(b.ts)); const seen = new Set(); const ids = []; for (const r of all) { if (!seen.has(r.userId)) { seen.add(r.userId); ids.push(r.userId); } } return ids; } app.post("/api/admin/reservations/notify-start", async (req, res) => { if (!requireAdmin(req, res)) return; try { const pid = resolveProductId(String(req.body?.productId || "").trim()); const message = String(req.body?.message || "").trim(); if (!pid) return res.status(400).json({ ok:false, error:"productId required" }); if (!message) return res.status(400).json({ ok:false, error:"message required" }); const userIds = buildReservationQueue(pid); const state = readNotifyState(); state[pid] = { idx: 0, userIds, message, updatedAt: new Date().toISOString() }; state.__lastPid = pid; writeNotifyState(state); if (userIds.length === 0) return res.json({ ok:true, info:"no_reservers", sent:false }); try { await client.pushMessage(userIds[0], { type:"text", text: message }); state[pid].idx = 1; state[pid].updatedAt = new Date().toISOString(); writeNotifyState(state); return res.json({ ok:true, productId: pid, sentTo: userIds[0], index: 1, total: userIds.length }); } catch (e) { return res.status(500).json({ ok:false, error:"push_failed", detail: e?.response?.data || String(e) }); } } catch (e) { return res.status(500).json({ ok:false, error:String(e) }); } }); app.post("/api/admin/reservations/notify-next", async (req, res) => { if (!requireAdmin(req, res)) return; try { const pidRaw = (req.body?.productId ?? readNotifyState().__lastPid ?? "").toString().trim(); const pid = resolveProductId(pidRaw); const n = Math.max(1, Math.min(100, Number(req.body?.count || 1))); const state = readNotifyState(); const st = state[pid]; if (!pid || !st) return res.status(400).json({ ok:false, error:"not_started" }); const { userIds, message } = st; let { idx } = st; const total = userIds.length; if (idx >= total) return res.json({ ok:true, done:true, index: idx, total }); const sentTo = []; for (let i=0; i<n && idx < total; i++, idx++) { const uid = userIds[idx]; try { await client.pushMessage(uid, { type:"text", text: message }); sentTo.push(uid); } catch (e) { console.error("notify-next push error:", e?.response?.data || e); } } state[pid].idx = idx; state[pid].updatedAt = new Date().toISOString(); writeNotifyState(state); return res.json({ ok:true, productId: pid, sent: sentTo.length, sentTo, index: idx, total }); } catch (e) { return res.status(500).json({ ok:false, error:String(e) }); } }); app.post("/api/admin/reservations/notify-stop", (req, res) => { if (!requireAdmin(req, res)) return; const pid = resolveProductId(String(req.body?.productId || "").trim()); const state = readNotifyState(); if (pid && state[pid]) { delete state[pid]; } if (state.__lastPid === pid) delete state.__lastPid; writeNotifyState(state); res.json({ ok:true, stopped: pid || true }); }); // Insight (ãƒ•ã‚©ãƒ­ãƒ¯ãƒ¼æ•°ãªã©) function yyyymmddJST(offsetDays = -1) { const now = new Date(); const jst = new Date(now.getTime() + 9*60*60*1000); jst.setDate(jst.getDate() + offsetDays); const y = jst.getUTCFullYear(); const m = String(jst.getUTCMonth()+1).padStart(2,"0"); const d = String(jst.getUTCDate()).padStart(2,"0"); return ${y}${m}${d}; } app.get("/api/admin/audience-count", async (req, res) => { if (!requireAdmin(req, res)) return; const candidates = []; if (req.query.date) candidates.push(String(req.query.date).replace(/[^0-9]/g, "")); else candidates.push(yyyymmddJST(-1), yyyymmddJST(-2)); const tried = []; for (const date of candidates) { try { const url = https://api.line.me/v2/bot/insight/followers?date=${date}; const r = await axios.get(url, { headers:{ Authorization:Bearer ${config.channelAccessToken} }, timeout:10000 }); const { followers = null, targetedReaches = null, blocks = null } = r.data || {}; return res.json({ ok:true, date, followers, targetedReaches, blocks, raw:r.data }); } catch (e) { const status = e?.response?.status || 500; const detail = e?.response?.data || { message: e.message || String(e) }; tried.push({ date, status, detail }); if (status === 401 || status === 403) return res.status(200).json({ ok:false, status, detail, tried }); } } return res.status(200).json({ ok:false, error:"no_usable_date", tried }); }); app.get("/admin/audience-count", (req, res) => { const qs = req.url.includes("?") ? req.url.slice(req.url.indexOf("?")) : ""; res.redirect(301, "/api/admin/audience-count" + qs); }); // ã‚»ã‚°ãƒ¡ãƒ³ãƒˆé…ä¿¡ï¼ˆãƒ†ã‚­ã‚¹ãƒˆ/ãƒ•ãƒ¬ãƒƒã‚¯ã‚¹ï¼‰ app.post("/api/admin/segment/send", async (req, res) => { if (!requireAdmin(req, res)) return; const userIds = Array.isArray(req.body?.userIds) ? uniq(req.body.userIds) : []; const message = (req.body?.message || "").trim(); if (userIds.length === 0) return res.status(400).json({ ok:false, error:"no_users" }); if (!message) return res.status(400).json({ ok:false, error:"no_message" }); const chunk = 500; const results = []; let okCount=0, ngCount=0; for (let i=0;i<userIds.length;i+=chunk) { const ids = userIds.slice(i, i+chunk); try{ await client.multicast(ids, [{ type:"text", text: message }]); results.push({ ok:true, size:ids.length }); okCount+=ids.length; } catch(e){ results.push({ ok:false, size:ids.length, error:e?.response?.data || String(e) }); ngCount+=ids.length; } } res.json({ ok:true, requested:userIds.length, sent:okCount, failed:ngCount, batches:results.length, results }); }); app.post("/api/admin/broadcast-flex", async (req, res) => { if (!requireAdmin(req, res)) return; try { // ã“ã“ã¯ altText/contents ä¸¡æ–¹ã‚’æ¸¡ã™ï¼ˆUIã‹ã‚‰ç›´æ¥å©ãç”¨ï¼‰ const altText = ensureAltText(req.body?.altText || "ãŠçŸ¥ã‚‰ã›"); const contents = validateFlexContents(req.body?.contents || req.body); // äº’æ› await client.broadcast([{ type: "flex", altText, contents }]); return res.json({ ok:true }); } catch (e) { const detail = e?.response?.data || e.message || String(e); return res.status(400).json({ ok:false, error: detail }); } }); // ====== Webhook ====== app.post("/webhook", line.middleware(config), async (req, res) => { try { const events = req.body.events || []; await Promise.all(events.map(handleEvent)); res.status(200).end(); } catch (err) { const detail = err?.originalError?.response?.data || err?.response?.data || err?.stack || err; console.error("Webhook Error detail:", JSON.stringify(detail, null, 2)); res.status(500).end(); } }); // ====== ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç† ====== async function handleEvent(ev) { try { // è»½é‡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ­ã‚° if (ev.type === "message" && ev.message?.type === "text") { try { const rec = { ts: new Date().toISOString(), userId: ev.source?.userId || "", type: "text", len: (ev.message.text || "").length }; fs.appendFileSync(MESSAGES_LOG, JSON.stringify(rec) + "\n", "utf8"); } catch {} const sessions = readSessions(); const uid = ev.source?.userId || ""; const textRaw = (ev.message.text || ""); const text = textRaw.trim(); // â˜… ä¹…åŠ©å°‚ç”¨ï¼šåŠè§’å€‹æ•°å…¥åŠ› â†’ æ•°é‡Flexã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¦å—å–æ–¹æ³•ã¸ const kusukeRe = /^ä¹…åŠ©(?:\s+(\d+))?$/i; const km = kusukeRe.exec(text); if (km) { const qtyStr = km[1]; if (!qtyStr) { sessions[uid] = { await: "kusukeQty" }; writeSessions(sessions); await client.replyMessage(ev.replyToken, { type:"text", text:"ä¹…åŠ©ã®å€‹æ•°ã‚’åŠè§’æ•°å­—ã§å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆä¾‹ï¼š2ï¼‰" }); return; } const qty = Math.max(1, Math.min(99, Number(qtyStr))); await client.replyMessage(ev.replyToken, methodFlex("kusuke-250", qty)); return; } if (sessions[uid]?.await === "kusukeQty") { if (!/^\d+$/.test(text)) { await client.replyMessage(ev.replyToken, { type:"text", text:"åŠè§’æ•°å­—ã§å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆä¾‹ï¼š2ï¼‰" }); return; } const qty = Math.max(1, Math.min(99, Number(text))); delete sessions[uid]; writeSessions(sessions); await client.replyMessage(ev.replyToken, methodFlex("kusuke-250", qty)); return; } // â˜… ãã®ä»–ï¼ˆè‡ªç”±å…¥åŠ›ï¼‰ï¼šåå‰â†’å€‹æ•°â†’å—å–æ–¹æ³•ï¼ˆä¾¡æ ¼0å›ºå®šï¼‰ if (sessions[uid]?.await === "otherName") { const name = (textRaw || "").slice(0, 50).trim(); if (!name) { await client.replyMessage(ev.replyToken, { type:"text", text:"å•†å“åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚" }); return; } sessions[uid] = { await: "otherQty", temp: { name } }; writeSessions(sessions); await client.replyMessage(ev.replyToken, { type:"text", text:ã€Œ${name}ã€ã§ã™ã­ã€‚å€‹æ•°ã‚’åŠè§’æ•°å­—ã§å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚ä¾‹ï¼š2 }); return; } if (sessions[uid]?.await === "otherQty") { if (!/^\d+$/.test(text)) { await client.replyMessage(ev.replyToken, { type:"text", text:"å€‹æ•°ã¯åŠè§’æ•°å­—ã§å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚ä¾‹ï¼š2" }); return; } const qty = Math.max(1, Math.min(99, Number(text))); const name = sessions[uid].temp?.name || "ãã®ä»–"; delete sessions[uid]; writeSessions(sessions); const id = other:${encodeURIComponent(name)}:0; await client.replyMessage(ev.replyToken, methodFlex(id, qty)); return; } // â˜… åº—é ­å—å–ã®ã¨ãã€åå‰ãŒæœªç™»éŒ²ãªã‚‰ã“ã“ã§å—ã‘å–ã‚‹ï¼ˆæ³¨æ–‡ç¢ºå®šç›´å‰ã«ä»•è¾¼ã‚“ã ã‚»ãƒƒã‚·ãƒ§ãƒ³ï¼‰ if (sessions[uid]?.await === "pickupName") { const name = text.slice(0, 30); if (!name) { await client.replyMessage(ev.replyToken, { type:"text", text:"ãŠåå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚ä¾‹ï¼šå±±ç”°å¤ªéƒ" }); return; } // åå‰ã ã‘ã§ã‚‚ addresses ã«ä¿å­˜ const book = readAddresses(); const prev = book[uid] || {}; book[uid] = { ...prev, name, ts: new Date().toISOString() }; writeAddresses(book); // ä¿ç•™ä¸­ã®æ³¨æ–‡æƒ…å ±ã‚’ç¶šè¡Œ const ord = sessions[uid]?.pendingOrder; delete sessions[uid]; writeSessions(sessions); if (ord) { await finalizeOrderAndReply(ev, ord.id, ord.qty, "pickup", "", "cash"); return; } } // â˜… äºˆç´„æ™‚ï¼šåå‰ãŒæœªç™»éŒ²ãªã‚‰å–å¾— â†’ äºˆç´„è¨˜éŒ²ã¸ if (sessions[uid]?.await === "reserveName") { const name = text.slice(0, 30); if (!name) { await client.replyMessage(ev.replyToken, { type:"text", text:"ãŠåå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚ä¾‹ï¼šå±±ç”°å¤ªéƒ" }); return; } const book = readAddresses(); const prev = book[uid] || {}; book[uid] = { ...prev, name, ts: new Date().toISOString() }; writeAddresses(book); const pending = sessions[uid]?.pendingReserve; // { id, qty } delete sessions[uid]; writeSessions(sessions); if (pending) { await writeReservationAndReply(ev, pending.id, pending.qty); return; } } // â˜… ç®¡ç†è€…å‘ã‘ãƒ†ã‚­ã‚¹ãƒˆã‚³ãƒãƒ³ãƒ‰ï¼ˆåœ¨åº«/äºˆç´„é€£çµ¡ï¼‰ if (ev.source?.userId && ADMIN_USER_ID && ev.source.userId === ADMIN_USER_ID) { const t = text.replace(/\s+/g, " ").trim(); if (t === "åœ¨åº«ä¸€è¦§") { const items = readProducts().map(p => ãƒ»${p.name}ï¼ˆ${p.id}ï¼‰ï¼š${Number(p.stock||0)}å€‹).join("\n"); await client.replyMessage(ev.replyToken, { type:"text", text: items || "å•†å“ãŒã‚ã‚Šã¾ã›ã‚“ã€‚" }); return; } if (t.startsWith("åœ¨åº« ")) { const parts = t.split(" "); if (parts.length === 2) { // åœ¨åº« {nameOrId} const pid = resolveProductId(parts[1]); const { product } = findProductById(pid); await client.replyMessage(ev.replyToken, { type:"text", text: product ? ${product.name}ï¼š${Number(product.stock||0)}å€‹ : "å•†å“ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚" }); return; } if (parts.length === 4) { // åœ¨åº« è¨­å®š|è¿½åŠ |æ¸›å°‘ {nameOrId} {æ•°å€¤} const op = parts[1]; const pid = resolveProductId(parts[2]); const val = Number(parts[3]); try { if (op === "è¨­å®š" || op.toLowerCase() === "set") { const r = setStock(pid, val, "admin-text"); const { product } = findProductById(pid); await client.replyMessage(ev.replyToken, { type:"text", text:[è¨­å®š] ${product?.name || pid}\n${r.before} â†’ ${r.after} å€‹ }); await maybeLowStockAlert(pid, product?.name || pid, r.after); return; } if (op === "è¿½åŠ " || op === "+" || op.toLowerCase() === "add") { const r = addStock(pid, Math.abs(val), "admin-text"); const { product } = findProductById(pid); await client.replyMessage(ev.replyToken, { type:"text", text:[è¿½åŠ ] ${product?.name || pid}\n${r.before} â†’ ${r.after} å€‹ï¼ˆ+${Math.abs(val)}ï¼‰ }); return; } if (op === "æ¸›å°‘" || op === "-" || op.toLowerCase() === "sub") { const r = addStock(pid, -Math.abs(val), "admin-text"); const { product } = findProductById(pid); await client.replyMessage(ev.replyToken, { type:"text", text:[æ¸›å°‘] ${product?.name || pid}\n${r.before} â†’ ${r.after} å€‹ï¼ˆ-${Math.abs(val)}ï¼‰ }); await maybeLowStockAlert(pid, product?.name || pid, r.after); return; } } catch (e) { await client.replyMessage(ev.replyToken, { type:"text", text:åœ¨åº«ã‚³ãƒãƒ³ãƒ‰ã‚¨ãƒ©ãƒ¼ï¼š${e.message || e} }); return; } } if (parts.length === 3 && /^[+-]\d+$/.test(parts[2])) { // åœ¨åº« {nameOrId} Â±æ•°å€¤ const pid = resolveProductId(parts[1]); const delta = Number(parts[2]); try{ const r = addStock(pid, delta, "admin-text"); const { product } = findProductById(pid); const sign = delta >= 0 ? "+" : ""; await client.replyMessage(ev.replyToken, { type:"text", text:[èª¿æ•´] ${product?.name || pid}\n${r.before} â†’ ${r.after} å€‹ï¼ˆ${sign}${delta}ï¼‰ }); await maybeLowStockAlert(pid, product?.name || pid, r.after); }catch(e){ await client.replyMessage(ev.replyToken, { type:"text", text:åœ¨åº«ã‚³ãƒãƒ³ãƒ‰ã‚¨ãƒ©ãƒ¼ï¼š${e.message || e} }); } return; } await client.replyMessage(ev.replyToken, { type:"text", text: "åœ¨åº«ã‚³ãƒãƒ³ãƒ‰:\nãƒ»åœ¨åº«ä¸€è¦§\nãƒ»åœ¨åº« ä¹…åŠ©\nãƒ»åœ¨åº« è¨­å®š ä¹…åŠ© 50 / è¿½åŠ  10 / æ¸›å°‘ 3\nãƒ»åœ¨åº« ä¹…åŠ© +5 / åœ¨åº« ä¹…åŠ© -2" }); return; } // äºˆç´„é€£çµ¡ç³»ï¼ˆé–‹å§‹/æ¬¡/åœæ­¢ ã¯ä¸‹ã®é€šå¸¸å°ç·šã®ç›´å‰ã«åˆ¥å‡¦ç†ã‚ã‚Šï¼‰ if (t.startsWith("äºˆç´„é€£çµ¡ ")) { const m = /^äºˆç´„é€£çµ¡\s+(\S+)\s+([\s\S]+)$/.exec(t); if (!m) { await client.replyMessage(ev.replyToken, { type:"text", text:"ä½¿ã„æ–¹ï¼šäºˆç´„é€£çµ¡ {å•†å“åã¾ãŸã¯ID} {æœ¬æ–‡}" }); return; } const pid = resolveProductId(m[1]); const message = m[2].trim(); const items = readLogLines(RESERVATIONS_LOG, 100000).filter(r => r && r.productId === pid && r.userId); const userIds = Array.from(new Set(items.map(r=>r.userId))); if (userIds.length === 0) { await client.replyMessage(ev.replyToken, { type:"text", text:äºˆç´„è€…ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚ï¼ˆ${pid}ï¼‰ }); return; } try { const chunk = 500; for (let i=0;i<userIds.length;i+=chunk) { await client.multicast(userIds.slice(i,i+chunk), [{ type:"text", text: message }]); } await client.replyMessage(ev.replyToken, { type:"text", text:äºˆç´„è€… ${userIds.length}åã«é€ä¿¡ã—ã¾ã—ãŸã€‚ }); } catch (e) { await client.replyMessage(ev.replyToken, { type:"text", text:é€ä¿¡ã‚¨ãƒ©ãƒ¼ï¼š${e?.response?.data?.message || e.message || e} }); } return; } } // é †æ¬¡é€šçŸ¥ï¼ˆãƒ†ã‚­ã‚¹ãƒˆã‚³ãƒãƒ³ãƒ‰ï¼‰â€” ç®¡ç†è€…é™å®š if (ev.source?.userId && ADMIN_USER_ID && ev.source.userId === ADMIN_USER_ID) { const tcmd = text.replace(/\s+/g," ").trim(); if (tcmd.startsWith("äºˆç´„é€£çµ¡é–‹å§‹ ")) { const m = /^äºˆç´„é€£çµ¡é–‹å§‹\s+(\S+)\s+([\s\S]+)$/.exec(tcmd); if (!m) { await client.replyMessage(ev.replyToken, { type:"text", text:"ä½¿ã„æ–¹ï¼šäºˆç´„é€£çµ¡é–‹å§‹ {å•†å“å/ID} {æœ¬æ–‡}" }); return; } const pid = resolveProductId(m[1]); const message = m[2].trim(); const userIds = buildReservationQueue(pid); const state = readNotifyState(); state[pid] = { idx:0, userIds, message, updatedAt:new Date().toISOString() }; state.__lastPid = pid; writeNotifyState(state); if (userIds.length === 0) { await client.replyMessage(ev.replyToken, { type:"text", text:äºˆç´„è€…ãŒã„ã¾ã›ã‚“ã€‚ï¼ˆ${pid}ï¼‰ }); return; } try { await client.pushMessage(userIds[0], { type:"text", text: message }); state[pid].idx = 1; state[pid].updatedAt = new Date().toISOString(); writeNotifyState(state); await client.replyMessage(ev.replyToken, { type:"text", text:é–‹å§‹ï¼š${pid}\n1/${userIds.length} ä»¶é€ä¿¡ã—ã¾ã—ãŸã€‚ã€Œäºˆç´„é€£çµ¡æ¬¡ã€ã§ç¶šè¡Œã€‚ }); } catch (e) { await client.replyMessage(ev.replyToken, { type:"text", text:é€ä¿¡ã‚¨ãƒ©ãƒ¼ï¼š${e?.response?.data?.message || e.message || e} }); } return; } if (tcmd === "äºˆç´„é€£çµ¡æ¬¡" || tcmd.startsWith("äºˆç´„é€£çµ¡æ¬¡ ")) { const m = /^äºˆç´„é€£çµ¡æ¬¡(?:\s+(\S+))?(?:\s+(\d+))?$/.exec(tcmd); const pid = resolveProductId(m?.[1] || readNotifyState().__lastPid || ""); const count = Math.max(1, Number(m?.[2] || 1)); const state = readNotifyState(); const st = state[pid]; if (!pid || !st) { await client.replyMessage(ev.replyToken, { type:"text", text:"å…ˆã«ã€Œäºˆç´„é€£çµ¡é–‹å§‹ {å•†å“} {æœ¬æ–‡}ã€ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚" }); return; } const { userIds, message } = st; let { idx } = st; const total = userIds.length; if (idx >= total) { await client.replyMessage(ev.replyToken, { type:"text", text:å®Œäº†æ¸ˆã¿ï¼š${idx}/${total} }); return; } let sent = 0; for (let i=0; i<count && idx < total; i++, idx++) { try { await client.pushMessage(userIds[idx], { type:"text", text: message }); sent++; } catch {} } state[pid].idx = idx; state[pid].updatedAt = new Date().toISOString(); writeNotifyState(state); await client.replyMessage(ev.replyToken, { type:"text", text:${sent}ä»¶é€ä¿¡ï¼š${idx}/${total} }); return; } if (tcmd.startsWith("äºˆç´„é€£çµ¡åœæ­¢")) { const m = /^äºˆç´„é€£çµ¡åœæ­¢(?:\s+(\S+))?$/.exec(tcmd); const pid = resolveProductId(m?.[1] || readNotifyState().__lastPid || ""); const state = readNotifyState(); if (pid && state[pid]) delete state[pid]; if (state.__lastPid === pid) delete state.__lastPid; writeNotifyState(state); await client.replyMessage(ev.replyToken, { type:"text", text:åœæ­¢ã—ã¾ã—ãŸï¼š${pid || "(æœªæŒ‡å®š)"} }); return; } } // é€šå¸¸å°ç·š if (text === "ç›´æ¥æ³¨æ–‡") { return client.replyMessage(ev.replyToken, productsFlex(readProducts())); } if (text === "ã‚¢ãƒ³ã‚±ãƒ¼ãƒˆ") { return client.replyMessage(ev.replyToken, surveyQ1()); } return client.replyMessage(ev.replyToken, { type: "text", text: "ã€Œç›´æ¥æ³¨æ–‡ã€ã¨é€ã‚‹ã¨å•†å“ä¸€è¦§ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚\nä¹…åŠ©ã¯ã€Œä¹…åŠ© 2ã€ã®ã‚ˆã†ã«ã€å•†å“åï¼‹åŠè§’å€‹æ•°ã§ã”å…¥åŠ›ãã ã•ã„ã€‚" }); } if (ev.type === "postback") { const d = ev.postback?.data || ""; if (d === "other_start") { const sessions = readSessions(); const uid = ev.source?.userId || ""; sessions[uid] = { await: "otherName" }; writeSessions(sessions); await client.replyMessage(ev.replyToken, { type: "text", text: "ãã®ä»–ã®å•†å“åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚" }); return; } if (d.startsWith("order_qty?")) { const { id, qty } = parse(d.replace("order_qty?", "")); return client.replyMessage(ev.replyToken, qtyFlex(id, qty)); } if (d.startsWith("order_method?")) { const { id, qty } = parse(d.replace("order_method?", "")); return client.replyMessage(ev.replyToken, methodFlex(id, qty)); } if (d.startsWith("order_region?")) { const { id, qty, method } = parse(d.replace("order_region?", "")); if (method === "delivery") return client.replyMessage(ev.replyToken, regionFlex(id, qty)); return client.replyMessage(ev.replyToken, paymentFlex(id, qty, "pickup", "")); } if (d.startsWith("order_payment?")) { let { id, qty, method, region } = parse(d.replace("order_payment?", "")); method = (method || "").trim(); region = (region || "").trim(); if (region === "-") region = ""; if (method === "pickup") { return client.replyMessage(ev.replyToken, paymentFlex(id, qty, "pickup", "")); } if (method === "delivery") { if (!region) return client.replyMessage(ev.replyToken, regionFlex(id, qty)); return client.replyMessage(ev.replyToken, paymentFlex(id, qty, "delivery", region)); } return client.replyMessage(ev.replyToken, methodFlex(id, qty)); } if (d.startsWith("order_confirm_view?")) { const { id, qty, method, region, payment } = parse(d.replace("order_confirm_view?", "")); let product; if (String(id).startsWith("other:")) { const parts = String(id).split(":"); const encName = parts[1] || ""; const priceStr = parts[2] || "0"; product = { id, name: decodeURIComponent(encName || "ãã®ä»–"), price: Number(priceStr || 0) }; } else { const products = readProducts(); product = products.find(p => p.id === id); if (!product) return client.replyMessage(ev.replyToken, { type: "text", text: "å•†å“ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚" }); } return client.replyMessage(ev.replyToken, confirmFlex(product, qty, method, region, payment, LIFF_ID)); } if (d === "order_back") { return client.replyMessage(ev.replyToken, productsFlex(readProducts())); } if (d.startsWith("order_confirm?")) { const { id, qty, method, region, payment } = parse(d.replace("order_confirm?", "")); // åº—é ­å—å–ã®ã¨ãåå‰ãŒæœªç™»éŒ²ãªã‚‰å…ˆã«åå‰å…¥åŠ› const uid = ev.source?.userId || ""; const book = readAddresses(); const hasName = !!(book[uid]?.name); if (method === "pickup" && !hasName) { const sessions = readSessions(); sessions[uid] = { await:"pickupName", pendingOrder:{ id, qty } }; writeSessions(sessions); await client.replyMessage(ev.replyToken, { type:"text", text:"åº—é ­ã§ãŠå‘¼ã³ã™ã‚‹ãŠåå‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚ä¾‹ï¼šå±±ç”°å¤ªéƒ" }); return; } await finalizeOrderAndReply(ev, id, qty, method, region, payment); return; } if (d.startsWith("order_reserve?")) { const { id, qty } = parse(d.replace("order_reserve?", "")); // äºˆç´„æ™‚ï¼šåå‰ãŒãªã‘ã‚Œã°å…ˆã«å–å¾— const uid = ev.source?.userId || ""; const book = readAddresses(); const hasName = !!(book[uid]?.name); if (!hasName) { const sessions = readSessions(); sessions[uid] = { await:"reserveName", pendingReserve:{ id, qty } }; writeSessions(sessions); await client.replyMessage(ev.replyToken, { type:"text", text:"äºˆç´„è€…åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚ä¾‹ï¼šå±±ç”°å¤ªéƒ" }); return; } await writeReservationAndReply(ev, id, qty); return; } } } catch (err) { console.error("handleEvent error:", err?.response?.data || err?.stack || err); if (ev.replyToken) { try { await client.replyMessage(ev.replyToken, { type: "text", text: "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚" }); } catch {} } } } // ====== æ³¨æ–‡ç¢ºå®šå‡¦ç†ï¼ˆå…±é€šï¼‰ ====== async function finalizeOrderAndReply(ev, id, qty, method, region, payment) { const need = Math.max(1, Number(qty) || 1); let product = null; let products = readProducts(); let idx = products.findIndex(p => p.id === id); if (String(id).startsWith("other:")) { const parts = String(id).split(":"); const encName = parts[1] || ""; const priceStr = parts[2] || "0"; product = { id, name: decodeURIComponent(encName || "ãã®ä»–"), price: Number(priceStr || 0), stock: Infinity }; idx = -1; // åœ¨åº«æ¸›ç®—ãªã— } else { if (idx === -1) { await client.replyMessage(ev.replyToken, { type:"text", text:"å•†å“ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚" }); return; } product = products[idx]; if (!product.stock || product.stock < need) { await client.replyMessage(ev.replyToken, reserveOffer(product, need, product.stock || 0)); return; } products[idx].stock = Number(product.stock) - need; writeProducts(products); await maybeLowStockAlert(product.id, product.name, products[idx].stock); } const regionFee = method === "delivery" ? (SHIPPING_BY_REGION[region] || 0) : 0; const codFee = payment === "cod" ? COD_FEE : 0; const subtotal = Number(product.price) * need; const total = subtotal + regionFee + codFee; const addrBook = readAddresses(); const addr = addrBook[ev.source?.userId || ""] || null; const order = { ts: new Date().toISOString(), userId: ev.source?.userId || "", productId: product.id, productName: product.name, qty: need, price: Number(product.price), subtotal, region, shipping: regionFee, payment, codFee, total, method, address: addr }; fs.appendFileSync(ORDERS_LOG, JSON.stringify(order) + "\n", "utf8"); const payText = payment === "cod" ? ä»£é‡‘å¼•æ›ï¼ˆ+${yen(COD_FEE)}) : payment === "bank" ? "éŠ€è¡ŒæŒ¯è¾¼" : "ç¾é‡‘ï¼ˆåº—é ­ï¼‰"; const userLines = [ "ã”æ³¨æ–‡ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ï¼", å—å–æ–¹æ³•ï¼š${method === "pickup" ? "åº—é ­å—å–ï¼ˆé€æ–™0å††ï¼‰" : å®…é…ï¼ˆ${region}ï¼‰}, æ”¯æ‰•ã„ï¼š${payText}, å•†å“ï¼š${product.name}, æ•°é‡ï¼š${need}å€‹, å°è¨ˆï¼š${yen(subtotal)}, é€æ–™ï¼š${yen(regionFee)}, ä»£å¼•ãæ‰‹æ•°æ–™ï¼š${yen(codFee)}, åˆè¨ˆï¼š${yen(total)} ]; if (method === "delivery") { userLines.push(""); userLines.push( addr ? ãŠå±Šã‘å…ˆï¼š${addr.postal || ""} ${addr.prefecture || ""}${addr.city || ""}${addr.address1 || ""}${addr.address2 ? " " + addr.address2 : ""}\næ°åï¼š${addr.name || ""}\né›»è©±ï¼š${addr.phone || ""} : "ä½æ‰€æœªç™»éŒ²ã§ã™ã€‚ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®ã€Œä½æ‰€ã‚’å…¥åŠ›ï¼ˆLIFFï¼‰ã€ã‹ã‚‰ç™»éŒ²ã—ã¦ãã ã•ã„ã€‚" ); } else { // åº—é ­å—å–ï¼šåå‰ãŒç™»éŒ²ã•ã‚Œã¦ã„ã‚Œã°è¡¨ç¤º if (addr?.name) { userLines.push("", ãŠå—ã‘å–ã‚Šåï¼š${addr.name}); } else { userLines.push("", "ãŠå—ã‘å–ã‚Šåã¯æ¥åº—æ™‚ã«ãŠä¼ºã„ã—ã¾ã™ã€‚"); } } await client.replyMessage(ev.replyToken, { type: "text", text: userLines.join("\n") }); // éŠ€è¡ŒæŒ¯è¾¼æ¡ˆå†…ï¼ˆå®…é… + bank ã®ã¨ãï¼‰ if (method === "delivery" && payment === "bank") { const bankMsg = (BANK_INFO ? â–¼ æŒ¯è¾¼å…ˆ\n${BANK_INFO} : "â–¼ æŒ¯è¾¼å…ˆ\nï¼ˆéŠ€è¡Œå£åº§æƒ…å ±ãŒæœªè¨­å®šã§ã™ã€‚ç®¡ç†è€…ã«ã”é€£çµ¡ãã ã•ã„ï¼‰") + (BANK_NOTE ? \n\n${BANK_NOTE} : "\n\nâ€»ã”å…¥é‡‘ç¢ºèªå¾Œã®ç™ºé€ã¨ãªã‚Šã¾ã™ã€‚"); try { await client.pushMessage(ev.source.userId, { type: "text", text: bankMsg }); } catch (e) { console.error("bank info send error:", e?.response?.data || e); } } // ç®¡ç†è€…é€šçŸ¥ const adminMsg = [ "ğŸ§¾ æ–°è¦æ³¨æ–‡", ãƒ¦ãƒ¼ã‚¶ãƒ¼IDï¼š${ev.source?.userId || ""}, å•†å“ï¼š${product.name}, æ•°é‡ï¼š${need}å€‹, å°è¨ˆï¼š${yen(subtotal)} / é€æ–™ï¼š${yen(regionFee)} / ä»£å¼•ï¼š${yen(codFee)} / åˆè¨ˆï¼š${yen(total)}, å—å–ï¼š${method}${method === "delivery" ? ï¼ˆ${region}ï¼‰ : ""} / æ”¯æ‰•ï¼š${payment}, (addr ? ä½æ‰€/æ°å/TELï¼š${addr.postal || ""} ${addr.prefecture || ""}${addr.city || ""}${addr.address1 || ""}${addr.address2 ? " " + addr.address2 : ""}\n${addr.name || ""} / ${addr.phone || ""} : "ä½æ‰€ï¼šæœªç™»éŒ²") ].join("\n"); try { if (ADMIN_USER_ID) await client.pushMessage(ADMIN_USER_ID, { type: "text", text: adminMsg }); if (MULTICAST_USER_IDS.length > 0) await client.multicast(MULTICAST_USER_IDS, { type: "text", text: adminMsg }); } catch {} } // ====== äºˆç´„è¨˜éŒ²ï¼†è¿”ä¿¡ ====== async function writeReservationAndReply(ev, productId, qtyRaw) { const products = readProducts(); const product = products.find(p => p.id === productId); if (!product) { await client.replyMessage(ev.replyToken, { type: "text", text: "å•†å“ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚" }); return; } const r = { ts: new Date().toISOString(), userId: ev.source?.userId || "", productId: product.id, productName: product.name, qty: Math.max(1, Number(qtyRaw) || 1), status: "reserved" }; fs.appendFileSync(RESERVATIONS_LOG, JSON.stringify(r) + "\n", "utf8"); await client.replyMessage(ev.replyToken, { type: "text", text: ["äºˆç´„ã‚’å—ã‘ä»˜ã‘ã¾ã—ãŸã€‚å…¥è·æ¬¡ç¬¬ã”æ¡ˆå†…ã—ã¾ã™ã€‚", å•†å“ï¼š${product.name}, æ•°é‡ï¼š${r.qty}å€‹].join("\n") }); try { const adminReserve = ["ğŸ“ äºˆç´„å—ä»˜", ãƒ¦ãƒ¼ã‚¶ãƒ¼IDï¼š${ev.source?.userId || ""}, å•†å“ï¼š${product.name}, æ•°é‡ï¼š${r.qty}å€‹].join("\n"); if (ADMIN_USER_ID) await client.pushMessage(ADMIN_USER_ID, { type: "text", text: adminReserve }); if (MULTICAST_USER_IDS.length > 0) await client.multicast(MULTICAST_USER_IDS, { type: "text", text: adminReserve }); } catch {} } // ====== Health ====== app.get("/health", (_req, res) => res.status(200).type("text/plain").send("OK")); app.get("/healthz", (_req, res) => res.status(200).type("text/plain").send("OK")); app.head("/health", (_req, res) => res.status(200).end()); app.get("/api/health", (_req, res) => { res.json({ ok: true, time: new Date().toISOString(), node: process.version, env: { PORT: !!process.env.PORT, LINE_CHANNEL_ACCESS_TOKEN: !!process.env.LINE_CHANNEL_ACCESS_TOKEN, LINE_CHANNEL_SECRET: !!process.env.LINE_CHANNEL_SECRET, LIFF_ID: !!process.env.LIFF_ID, ADMIN_API_TOKEN: !!ADMIN_API_TOKEN_ENV, ADMIN_CODE: !!ADMIN_CODE_ENV, BANK_INFO: !!BANK_INFO, BANK_NOTE: !!BANK_NOTE, } }); });
