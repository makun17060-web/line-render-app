// ===== Admin Orders APIs (fix totals mismatch + shipped notify) =====
const express = require("express");
const { Pool } = require("pg");

// 既存のapp/lineClient/poolがあるならそれを使ってOK
// ここでは pool/lineClient が既に定義されている前提にしています。
// もし無ければ下を使ってください：
// const pool = new Pool({ connectionString: process.env.DATABASE_URL, ssl: { rejectUnauthorized: false } });
// const { Client } = require("@line/bot-sdk"); const lineClient = new Client({ channelAccessToken: process.env.LINE_CHANNEL_ACCESS_TOKEN });

function requireAdmin(req) {
  const token = (req.query.token || "").trim();
  const okToken = (process.env.ADMIN_API_TOKEN || process.env.ADMIN_CODE || "").trim();
  if (!okToken) throw new Error("ADMIN_API_TOKEN/ADMIN_CODE not set");
  if (!token || token !== okToken) {
    const e = new Error("unauthorized");
    e.status = 401;
    throw e;
  }
}

function yen(n) {
  return Number(n || 0).toLocaleString("ja-JP") + "円";
}

function buildItemsArray(order) {
  const items = Array.isArray(order.items) ? order.items : [];
  return items.map((it) => {
    const name = it.name || it.id || "商品";
    let price = Number(it.price ?? it.unitPrice ?? 0);
    const qty = Number(it.qty || 0) || 0;

    // 久助：単価が無いときだけ補完（運用：250円）
    if (!price && /久助/.test(name)) price = 250;

    return { name, price, qty };
  });
}

function sumItems(items) {
  return (items || []).reduce((s, it) => s + (Number(it.price || 0) * Number(it.qty || 0)), 0);
}

function normalizeOrderTotals(orderRow) {
  const shipping = Number(orderRow.shipping ?? 0) || 0;
  const codFee = Number(orderRow.cod_fee ?? 0) || 0;

  // DBのitems_subtotal（誤ってcodが混ざってる可能性あり）
  const itemsSubtotalRaw = Number(orderRow.items_subtotal ?? 0) || 0;

  const items = buildItemsArray(orderRow);
  const itemsCalc = sumItems(items);

  let itemsSubtotal = itemsSubtotalRaw;
  let warning = "";

  // 代引混在パターン：items_subtotal - items_calc == cod_fee
  if (itemsCalc > 0 && codFee > 0 && (itemsSubtotalRaw - itemsCalc) === codFee) {
    itemsSubtotal = itemsCalc;
    warning = `fix: items_subtotal included cod_fee(${codFee})`;
  } else if (itemsSubtotalRaw === 0 && itemsCalc > 0) {
    itemsSubtotal = itemsCalc;
    warning = "fix: items_subtotal was 0";
  } else if (itemsCalc > 0 && itemsSubtotalRaw > 0 && itemsSubtotalRaw !== itemsCalc) {
    warning = `warn: mismatch raw=${itemsSubtotalRaw} calc=${itemsCalc}`;
  }

  const finalTotal = Number(orderRow.final_total ?? 0) || (itemsSubtotal + shipping + codFee);

  return { items, itemsCalc, itemsSubtotalRaw, itemsSubtotal, shipping, codFee, finalTotal, warning };
}

// GET /api/admin/orders?date=YYYYMMDD
app.get("/api/admin/orders", async (req, res) => {
  try {
    requireAdmin(req);

    const date = String(req.query.date || "").trim(); // JSTの日付フィルタを想定（YYYYMMDD）
    // 既存スキーマに合わせて調整してください：
    // orders(ts timestamptz, order_number, user_id, line_user_id, address jsonb, items jsonb, items_subtotal int, shipping int, cod_fee int, final_total int, payment text, method text, region text)
    const where = [];
    const params = [];
    if (date && /^\d{8}$/.test(date)) {
      // JST日付の0:00〜24:00 をUTCに変換するのが理想だが、簡易版：
      // ここは “tsをJSTで文字列化して前方一致” などあなたの実装に合わせてOK
      // 例として server側でJST基準の範囲を作る：
      const y = date.slice(0,4), m = date.slice(4,6), d = date.slice(6,8);
      const startJst = `${y}-${m}-${d}T00:00:00+09:00`;
      const endJst   = `${y}-${m}-${d}T23:59:59.999+09:00`;
      where.push(`ts >= $${params.length+1} AND ts <= $${params.length+2}`);
      params.push(startJst, endJst);
    }

    const sql =
      `SELECT
         id, ts, order_number, user_id, line_user_id,
         address, items,
         items_subtotal, shipping, cod_fee, final_total,
         payment, method, region
       FROM orders
       ${where.length ? "WHERE " + where.join(" AND ") : ""}
       ORDER BY ts DESC
       LIMIT 300`;

    const r = await pool.query(sql, params);

    const itemsOut = r.rows.map((row) => {
      const t = normalizeOrderTotals(row);
      return {
        ts: row.ts,
        orderNumber: row.order_number || "",
        userId: row.user_id || row.line_user_id || "",
        lineUserId: row.line_user_id || row.user_id || "",
        address: row.address || null,
        items: Array.isArray(row.items) ? row.items : [],
        // adminが使いやすいように統一キーでも返す
        itemsSubtotal: t.itemsSubtotal,
        shipping: t.shipping,
        codFee: t.codFee,
        finalTotal: t.finalTotal,
        payment: row.payment || "",
        method: row.method || "",
        region: row.region || "",
        // デバッグ
        warn: t.warning ? { type: t.warning, raw: t.itemsSubtotalRaw, calc: t.itemsCalc } : null,
      };
    });

    res.json({ ok: true, items: itemsOut });
  } catch (e) {
    console.error("[admin/orders]", e);
    res.status(e.status || 500).json({ ok: false, error: e.message || String(e) });
  }
});

// POST /api/admin/orders/notify-shipped
// body: { userId, orderNumber?, orderKey?, message? }
app.post("/api/admin/orders/notify-shipped", express.json(), async (req, res) => {
  try {
    requireAdmin(req);

    const userId = (req.body.userId || "").trim();
    const orderNumber = (req.body.orderNumber || "").trim();
    if (!userId) return res.status(400).json({ ok: false, error: "userId required" });

    let order = null;
    if (orderNumber) {
      const r = await pool.query(
        `SELECT * FROM orders WHERE order_number = $1 LIMIT 1`,
        [orderNumber]
      );
      order = r.rows[0] || null;
    }

    // messageが来ても、金額はサーバーで組み立てる（安全）
    let msg;
    if (order) {
      const t = normalizeOrderTotals(order);
      const itemsTxt = t.items.length
        ? t.items.map(it => `・${it.name} x ${it.qty}`).join("\n")
        : "（内容不明）";

      const totalTxt =
        `商品合計：${yen(t.itemsSubtotal)}\n` +
        `送料：${yen(t.shipping)}\n` +
        (t.codFee ? `代引手数料：${yen(t.codFee)}\n` : "") +
        `合計：${yen(t.finalTotal)}`;

      msg =
        "【発送のお知らせ】\n" +
        "手造りえびせんべい 磯屋です。\n\n" +
        "ご注文いただいた商品を、本日発送いたしました。\n\n" +
        "▼ご注文内容\n" + itemsTxt + "\n\n" +
        totalTxt + "\n\n" +
        "商品到着まで今しばらくお待ちくださいませ。";
    } else {
      // orderNumber無し/見つからない場合は、受け取ったmessageを送る（最低限）
      msg = (req.body.message || "").trim();
      if (!msg) return res.status(400).json({ ok: false, error: "order not found and message empty" });
    }

    await lineClient.pushMessage(userId, { type: "text", text: msg });

    res.json({ ok: true });
  } catch (e) {
    console.error("[admin/notify-shipped]", e);
    res.status(e.status || 500).json({ ok: false, error: e.message || String(e) });
  }
});

// （任意）POST /api/admin/orders/repair-mismatch
// body: { orderNumbers: ["...","..."] }
app.post("/api/admin/orders/repair-mismatch", express.json(), async (req, res) => {
  try {
    requireAdmin(req);

    const orderNumbers = Array.isArray(req.body.orderNumbers) ? req.body.orderNumbers.map(s => String(s||"").trim()).filter(Boolean) : [];
    if (orderNumbers.length === 0) return res.status(400).json({ ok: false, error: "orderNumbers required" });

    const q = `
      WITH calc AS (
        SELECT
          o.id,
          o.order_number,
          o.items_subtotal,
          o.cod_fee,
          COALESCE(SUM((COALESCE((it->>'price')::int,0))*(COALESCE((it->>'qty')::int,0))),0) AS items_calc
        FROM orders o
        CROSS JOIN LATERAL jsonb_array_elements(o.items) it
        WHERE o.order_number = ANY($1)
        GROUP BY o.id, o.order_number, o.items_subtotal, o.cod_fee
      )
      UPDATE orders u
      SET
        items_subtotal = c.items_calc,
        final_total = (c.items_calc + u.shipping + u.cod_fee)
      FROM calc c
      WHERE u.id = c.id
        AND (c.items_subtotal - c.items_calc) = c.cod_fee
      RETURNING u.order_number, c.items_subtotal AS before_items_subtotal, c.items_calc AS after_items_subtotal, u.cod_fee;
    `;

    const r = await pool.query(q, [orderNumbers]);
    res.json({ ok: true, repaired: r.rows });
  } catch (e) {
    console.error("[admin/repair-mismatch]", e);
    res.status(e.status || 500).json({ ok: false, error: e.message || String(e) });
  }
});
